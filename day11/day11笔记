
异常：
    Throwable是java语言中所有异常的超类
    Throwable有两个子类，
    Exception：编译器异常，进行编译程序，出现的问题
        RunTimeException：运行期异常，指程序在运行期间出现的异常
        将Exception处理掉，程序可以继续执行
    Error：错误，必须修改源代码，程序才能重新开始运行

    异常的产生过程及如何处理异常
        若代码访问的索引，在数组中并不存在，那么java的JVM就会检测出异常之后，JVM会做两件事情：
            1、JVM会根据一场产生的原因创建异常对象，这个异常对象包含了异常产生的内容原因和位置
            2、若访问数组程序中并没有异常的处理逻辑(try...catch)，那么JVM会将异常对象抛出给遗产的调用者main方法，来处理异常
            3、main方法接受到了异常对象，但是main方法也没有异常的处理逻辑，就继续将异常抛出给main方法的调用者JVM进行处理
            4、JVM接受到了异常对象，将异常对象及其产生的内容、原因以及位置以红色的字体打印在控制台
            5、JVM会终止当前正在执行的java程序

    异常的处理：
        throw关键字：使用throw在指定的方法中抛出指定的异常
        使用格式：
            throw new 对象("异常产生的原因")
        注意事项：
            1、throw关键字，必须写在方法的内部，
            2、new出的对象，必须是Exception或者是Exception的子类对象
            3、throw抛出指定的异常对象，那么我们就必须处理这个异常对象 throw关键字后面创建的是RuntimeException或者是RuntimeException的子类
               我们可以不处理，会默认交给JVM的处理(打印异常，中断程序)
               throw后创建的是编译异常，那么我们必须处理这个异常，要么throw要么try...catch
        在未来的工作中，我们必须对传过来的参数，进行合法性校验，若输入不合法，那么我们一定要用抛出异常的方式，告诉方法的调用者
    Objects的非空判断
        Objects中的静态方法
        public static <T> T requireNonNull(E obj){
              if(obj == null){
                  throw new NullPointerException();
              return obj;
              }
        }

        throws关键字，异常处理的第一种方式，交给别人处理
            作用：当方法内部抛出异常对象的时候，我们就必须处理这个异常对象，可以使用throws关键字处理处理异常，会将异常的处理声明抛出给调用者
                 自己不进行处理，而是交给别人处理，最后交给JVM进行处理
            使用格式：
                在方法声明时使用
                    修饰符 返回值类型 方法名(参数列表) throws{
                        throws new AAAException("异常产生的原因");
                        throws new BBBException("异常产生的原因");
                        throws new CCCException("异常产生的原因");
                    }
                注意：
                    1、throws关键字，必须在方法声明处
                    2、throws关键字，后面声明的异常必须是Exception或者是Exception的子类
                    3、方法内部若抛出了多个异常，那么throws后面也要声明多个异常，若抛出的异常对象有子父类对象，那么直接申明父类即可
                    4、调用申明抛出的异常，那么就必须处理申明的异常，要么继续使用throws，将异常交给方法的调用者，最终交给JVM处理，
                       要么try....catch自己处理异常

        try...catch捕获异常
            异常处理的第二种方式，自己处理异常
            格式：
                try{
                    可能产生异常的代码
                }catch(定义一个异常变量，用来接收try出来的异常){
                    异常处理逻辑，异常捕获之后，如何处理异常
                    一般在工作中，会将他记录在日志中
                }
                .....
                catch(异常类名 变量名){
                    处理逻辑
                }
            注意事项：
                1、try中抛出多个异常对象，就会产生多个catch来处理这些异常对象
                2、若try产生了异常，那么就会执行catch中的异常处理逻辑，执行完catch后的处理逻辑，则继续执行try...catch后面的代码
                   若try中没有产生代码，那么就不会执行catch中异常的处理逻辑，执行完try的代码，继续执行try...catch后面的代码
                3、try抛出什么异常对象，catch就要定义什么异常变量，来接收这个异常对象

    Throwable类定义了三个异常处理的异常：
        String getMessage() 返回此Throwable的简短消息字符串
        String toString() 返回此Throwable的详细消息字符串
        void printStackTrace() JVMd打印的异常对象，默认调用该方法，异常信息最为全面

    Finally代码块
        格式：
            try{
                可能产生异常的代码
            }catch(定义一个异常变量，用来接收try出来的异常){
                异常处理逻辑，异常捕获之后，如何处理异常
                一般在工作中，会将他记录在日志中
            }
            .....
            catch(异常类名 变量名){
                处理逻辑
            }finally{
                无论编译是否出现异常，该代码块都会执行
            }
        注意事项：
            1、finally不能单独使用，必须和try一起使用
            2、finally一般用于资源释放，无论程序是否出现异常，我们在最后都要进行资源释放

异常的注意事项：
    多异常的捕获及处理：
        1、多个异常分别处理
        2、多个异常一次捕获，然后分别处理
            注意事项：
                catch里面的定义的异常变量，若有子父类关系，那么子类的异常对象必须写在上面否则就会错
        3、多个捕获一次捕获，一次处理
            运行时异常抛出也可以不进行处理，既不捕获也不申明输出，默认会给JVM处理
    若finally，中有return语句，永远返回的都是finally的结果，要避免该种情况
    子父类异常：
        若父类中抛出多个异常，子类重写父类异常时，抛出与父类相同的异常或是父类异常的子类或者不抛出异常
        父类方法没有抛出异常，子类重写父类的方法时，也不可能抛出异常，此时子类产生该异常，只能捕获处理，不能声明抛出
        注意：父类异常什么样子类异常什么样

自定义异常类：
    java提供的异常类，不够使用时，自己定义异常类
    格式：
        public class XXXException extends Exception / RuntimeException{
            // 添加空参数的构造方法
            // 添加一个带异常信息的构造方法
        }
    注意：
        1、自定义异常类都是以Exception结尾的，说明这是一个异常类
        2、自定义异常类必须继承Exception或者是继承RuntimeException
            若继承的是Exception：那么自定义的异常类就是一个编译异常，若方法内部抛出了编译器异常，就必须处理编译器异常，要么throw，要么try...catch
            若继承的是RuntimeException：若方法中跑出的是运行期异常，那么无处理，交给虚拟机处理即可

























