
数据结构：
    1、栈：先进后出 入口出口在同一侧
    2、队列 先进先出 入口出口不再同一侧
    3、数组
        查询快：根据索引进行查询
        增删慢：因为数组的长度是一定的，若是要进行增删操作，那么必须增加一个新的数组，将数组放入新数组以后，旧的数组就会被垃圾回收
    4、链表
        查询慢：链表中的元素不连续，每次查询元素都需要从头进行查询
        增删快：链表结构增加或者删除一个元素，他对于链表的整体结构没有影响
        分类：
            单向链表：存储元素和取出元素的顺序有可能会不一致
            双向链表：有两条链子，其中有一条链子是记录元素的顺序的，是一个有序的集合

List集合
    有序的集合：存储和取出元素的顺序是一致的
    有索引的集合：包含了一些带索引的方法
    允许有重复的元素

    List集合中带有索引的方法：
        public void add(int index, E element) 将指定的元素，添加到集合中指定的位置
        public E get(int index)  返回指定位置的元素
        public E remove(int index) 移除指定位置的元素，并返回该元素的值
        public E set(int index, E element) 用指定的元素替换集合中指定位置的元素，返回更新前的元素
        注意事项：
            操作索引时，一定要防止索引越界异常
            IndexOutOfBoundException：索引越界异常
            ArrayLIstOfBoundException：数组越界异常
            StringIndexOutOfBoundException：字符串索引越界异常

ArrayList集合，本质是数组结构，查找快，增删慢

LinkedList集合
    List集合的链表实现
    特点：
        1、底层是链表结构，查询慢，增删快
        2、包含了大量操作首尾元素的方法
        注意：使用的是LinkedList集合特有的方法，不可以使用多态

Vector集合
     可以实现可增长的对象数组

Set集合
    不允许包含重复元素，不带有索引方法，也不能使用普通for循环遍历
    HashSet实现了Set集合
        1、不允许包含重复的元素
        2、不带有索引的方法
        3、是一个无序的结合，放入顺序与取出顺序有可能不一致
        4、底层是一个Hash表结构，查询速度快

    哈希值：
        是一个十进制整数，游戏厅随机给出(就是对象的地址，但是是对象的逻辑地址)
        Object类方法，可以返回对象的哈希值
        int hashCode() 返回对象的哈希码值
        hashCode的源码：
            public native int hashCode();
            native:代表方法调用的本地操作系统方法
        String继承了Object方法，所以也可以使用hashCode

    HashSet集合存储数据的结果(哈希表)
        哈希表 = 数组 + 链表
        哈希表 = 数组 + 红黑树
        哈希表的特点：查询速度快
        若链表的长度超过八位，那么就会将数据结构转化为红河树结构，目的是增加查询速度
    Set集合不重复元素的原理
        Set再使用add方法时，add会调用元素的hashCode方法和equals方法，判断元素是否重复，先检查hash值是否相同再使用equals，判断是否元素重复
    HashSet存储自定义类型
        Set集合报错：存储的元素(String, Integer, person)必须重写hashCode和equals方法
    LinkedHashSet集合，继承了HashSet集合
        特点：
            1、底层是个哈希表(数组 + 链表/红黑树) + 链表，增加链表的作用是记录元素的存储顺序，保证元素的有序性

可变参数：
    使用前提：当方法的参数列表的参数的数据类型已经确定，但是参数的个数还不确定，就可以使用可变参数
    使用格式：定义方法时使用
        修饰符 返回值类型 方法名(数据类型 ... 变量名)
    原理：
        可变参数底层是一个数组，根据传递参数的个数，会创建不同长度的数组，来存储这些参数
        传递参数的个数可以是0-n
    注意事项：
        1、一个方法的参数列表，只能有一个可变参数
        2、若方法的参数有多个，那么必须将可变参数写在参数列表的末尾
    可变参数的终极写法
        public static void method(Object...obj)

Collections
    存在很多常用方法。
    注意事项：sort方法适用前提，被排序的集合里存储的元素，必须实现CompareTo方法，使用的是自定义类型 需要重写
    排序规则：自己(this) - 参数 升序， 参数 - 自己(this) 降序
    Comparator进行排序: o1 - o2 就是升序
    * Comparable和Comparator的区别：
    *   Comparable：自己(this)和别人进行比较，自己需要实现Comparable的接口，重写比较的规则
    *   Comparator：相当于找第三方的裁判来比较两个人
    * */





















