
并发和并行：
    并发：两个或多个事件不再同一个时间段内发生
    并行：两个或多个事件在同一时间段内发生

线程和进程：
    进程：是指内存中运行的应用程序
         内存：所有的应用程序都要进入内存中执行，临时存储在RAM中。点击应用程序执行，进入到内存中，占用内存进行执行，进入
             内存的程序，叫做进程。若在电脑的任务管理器中点击取消进程，就将进程从内存中清除

    线程：线程是进程的执行单元，一个进程至少要有一个线程，若一个进程中有多个线程，那么该应该程序为多线程应用程序
         CPU：中央处理器，对数据进行计算，指挥电脑中的软件和硬件干活
         线程是属于进程的，线程是进程的执行单元，负责程序的执行
         单核心单线程CPU执行多线程程序时，轮流在多个线程之间高速切换，这样会导致效率低下，切换时间为1/n ms
         多核心多线程CPU执行多线程程序时，可以同时执行多个线程，这多个线程在多个任务之间做高速的切换，速度是多线程的n倍(n线程)

    线程的调度：
        分时调度：所有线程轮流被CPU执行，平均分配给每个CPU的运行时间
        抢占式调度：抢先由优先级较高的线程使用CPU，若线程的优先级相同，那么会随机选择一个(线程的随机性)，JVM使用的是抢占式调度

创建线程类：
    主线程，执行main的线程，单线程程序，从main方法开始由上到下依次执行

创建多线程类：
    创建多线程程序的第一种方式：创建Tread类的子类
    java.lang.Thread类为描述线程的类，我们实现多线程程序就必须继承Tread类
    实现步骤：
        1、创建一个Tread类的子类
        2、在Tread类的子类中重写Tread类中的run方法，设置线程任务(指明开启线程需要做的任务)
        3、创建Tread类的子类对象
        4、调用Tread类子类中的方法start()开启新的线程，执行run方法
    结果是两个线程并发的执行，当前线程(从调用返回给start方法)和另一个线程(创建的新线程，调用run方法)
    多次启动一个线程是非法的，特别是该进程已经结束执行后，不能重新开始启动
    java程序属于强制式调度，同一个优先级，就随机选择一个执行

    多线程My_Thread的原理：
        结果为：随机性打印
        JVM执行main程序，找OS开辟一条main方法通向CPU的路径，这个路径叫main线程(主线程),CPU通过该线程的的路径就可以执行main方法
        在我们创建My_Thread对象时，JVM又会开辟一条路径，用来执行run方法，对于CPU而言，就有两条路径，CPU便有了选择的权利，CPU会随机
        一条路径执行，所以CPU便有了随机打印的结果
        在JVM执行main方法时，会在栈空间开辟一块内存，用来执行main方法的运算，在创建My_Thread对象时，又会在栈空间开辟一块内存，用来执行
        My_Thread中的run方法，所以两个进程互不影响，他们运行在不同的栈空间中

Thread类的常用方法：
    1、获取当前线程的名称
        使用Thread中的方法getName()获取当前线程的名称
        可以先获取到正在执行的线程，再使用线程中的方法getName获取线程的名称
            static Thread currentThread() 返回正在执行线程对象的引用
        线程名称：
                主线程：main
                新线程：Thread-0 Thread-1 Thread-2
    2、设置线程名称(了解)
        1、使用Thread类中的方法setName(名字)， void setName(String name)  改变线程名称，使之与参数name相同
        2、创建一个带参数的构造方法，参数传递的是线程的名称调用父类的带参构造方法，将线程名称传递给父类，让父类的Thread给子线程起名字
    3、sleep是当前进程以指定的毫秒数进行暂停
        public static void sleep(long millis) 使当前进程暂停指定毫秒数，毫秒数结束以后，程序继续执行 Thread.sleep(1) 睡眠一毫秒

创建多线程程序的第二种方法：
    java.lang.Runnable
    Runnable 接口应该由打算通过某一线程执行其实例的类来实现，类必须定义一个无参的run方法
    java.lang.Thread
    Thread(Runnable target) 分配新的Thread对象
    Thread(Runnable target, String name)分配新的Thread对象
    实现步骤：
        1、创建一个Runnable接口的实现类
        2、在实现类中重写Runnable接口的run方法，设置线程任务
        3、创建一个Runnable接口的实现类对象
        4、创建Thread对象，在它的构造方法中传递Runnable实现类对象
        5、调用Thread类中的start方法，开启新的线程执行run方法
    实现Runnable接口，创建多线程程序的好处：
        1、避免了单继承的局限性，一个类若继承了Thread类，那么就不能继承其他的类，实现了Runnable接口，他还可以实现其它的类，
           还可以实现其他的接口
        2、增强了程序的扩展性，降低了程序的耦合性(解耦),实现Runnable接口的方式，将设置线程任务和开启新线程进行了分离(解耦)，
           实现类中，重写了run方法，用来设置线程任务，而创建Thread对象，调用start方法，用来开启新的线程

使用匿名内部类的方式，实现多线程的创建
    匿名：没有名字 内部类：写在其他类内部的类
    匿名内部类的作用就是简化代码，将子类继承父类重写父类的方法，创建子类对象合一步完成，将实现类接口，重写接口中的方法，创建实现
    类的方法，进行一步的完成
    匿名内部类的最终产物：子类/实现类对象，而这个类没有名字, 该类只能使用一次
    格式：
        new 父类/接口(){
            重复父类/接口中的方法
        };

线程安全问题：
    单线程问题是没有线程安全问题的
    线程安全问题是因为多线程之间共享资源引起的
    原理：
        在卖票过程中，出现了重复的票和不存在的票

使用线程同步问题解决线程安全问题：
    同步代码块：
        格式：
            synchronized(锁对象){
                可能会出现线程安全问题的代码(访问了共享数据的代码)
            }
        注意：
            1、同步代码块中的对象可以是任意的对象
            2、但是必须保证多个线程使用的锁对象是同一个
            3、锁对象的作用：将同步代码块进行封锁，只让一个线程在同步代码块中执行
    同步技术的原理：
         使用一个锁对象，该锁对象叫做同步锁，也叫对象锁，也叫对象监视器
         三个锁共同抢夺CPU的执行权，谁抢到了，谁就执行(卖票),执行run方法，遇到synchronized同步代码块，这时会检查
         同步代码块是否有锁对象，发现有就会获取到锁对象进入到同步中执行。下一个进程到达时，会发现没有锁对象，这时该进程
         就会进入到阻塞状态，就会一直等待上一个线程执行完毕，交出锁对象。这时后来的线程会获取到锁对象，进入到内存中执行
         总结：
            同步中的线程没有执行完毕，不会释放锁，同步外的线程进不去同步，这时同步中始终只有一个线程正在执行，正在执行共享数据

    同步方法：
        使用步骤：
            1、将访问了共享数据代码抽取出来，放到一个方法中
            2、在方法中添加synchronized
        格式：
            修饰符 synchronized 返回值类型 方法名(参数列表)：
             {
                方法体
             }
        原理：
            也会将代码内容锁住，只允许一个线程执行，同步方法的锁对象，就是实现类对象 new RunnableImpl2() 也就是this

    静态同步方法：
        静态方法也会将代码块锁住，静态方法的锁对象是，因为在创建对象之前就产生，静态方法优先于对象，静态方法的锁对象是本类的class属性，
        class文件对象

线程的状态：
    计时等待
    锁阻塞状态
    无限等待状态(Waiting)

等待唤醒机制：
    多个线程处理同一个资源，但是处理的动作是不相同的
    等待唤醒机制(进程之间的通信)
    重点：有效地利用资源(生产一个包子, 吃一个包子......)
    通信：对包之的状态进行判断：
        没有包子：唤醒生产者进程，消费者线程等待，生产者线程执行，生产者完成工作以后，修改资源的状态
        有包子：生产者线程唤醒消费者线程，生产者线程等待，消费者线程执行，消费者执行完毕以后，修改资源状态
        循环往复......

等待唤醒需求分析：
    资源类：包子类
        设置包子的属性：皮，馅
        报纸的状态：有 true 没有 false

    生产者：包子铺，这是一个线程类，可以继承Thread
        设置线程任务：生产包子
            对包子的状态进行判断：true有包子，包子铺调用wait方法进入等待状态 false没有包子，生产包子
            交替生产两种包子(i % 2)
            包子铺生产好包子，修改报纸的状态为true，唤醒吃包子(消费者)线程吃包子

    消费者：也是一个线程类，可以继承Thread类
        设置线程任务：吃包子
            对报纸的状态进行判断，false没有包子，调用wait方法等待 true有包子，吃包子，吃完包子以后修改
            唤醒包子铺线程，让其做包子

    测试类：
        包含main方法类，程序启动的入口
        创建包子对象，创建包子铺线程，创建吃包子线程

线程池：
    使一个线程执行一个任务完毕以后，线程不自动销毁，使其执行其他任务，需要线程池来实现
    1、线程池为一个容器(ArrayList, HashSet, LinkedList<Thread>, HashMap)，当程序第一次启动的时候，创建多个线程，将其置入一个
    集合中
    2、当使用线程时，就可以从集合中将线程取出来使用，例：Thread t = List.remove()返回的是移除的元素，线程只能被一个任务使用
       Thread t = LinkedList.removeFirst()返回的也是个线程
    3、当使用完毕以后，我们需要把线程归还给线程池 List.add(t) LinkedList.addLast(t)




























